import tweepyimport secret#override tweepy.StreamListener to add logic to on_statusclass MyStreamListener(tweepy.StreamListener):    def on_status(self, status):        print status.text.encode('utf-8'),         status.created_at,         status.user.screen_name.encode('utf-8'),         status.user.location        # print status.text.encode('utf-8')    # def text_parsing(self, text):          # def on_data(self, data):    #     print data    #     return True    def on_error(self, status_code):        if status_code == 420:            #returning False in on_data disconnects the stream            return False        print status_codemyStreamListener = MyStreamListener()myStream = tweepy.Stream(auth = secret.auth, listener=myStreamListener)myStream.filter(track=['python', 'javascript', 'ruby'])# process output to json# # # # # API: Get all active listings# Only include data that is needed for sorting, filtering,# and viewing in a list and map in the client.# TODO: the listing document generation shouldn't be done here# @app.route('/api/listings.json')# def api_listings():#   listings = Listing.query.filter_by(suspend=False)#   output = []#   for listing in listings:#     output.append({#       "id": listing.id,#       "addr": listing.addr,#       "name": listing.name,#       "contact": {#         "id": listing.manager.id,#         "name": listing.manager.contact_name,#         "company": listing.manager.contact_company,#         "email": listing.manager.contact_email,#         "phone": listing.manager.contact_phone#       },#       "location": {#         "distance": listing.distance,#         "duration": listing.duration,#         "lat": listing.lat,#         "lng": listing.lng#       },#       "bedrooms": listing.bedrooms,#       "bathrooms": listing.bathrooms,#       "rent": listing.rent,#       "photos": listing.get_photo_urls()#     })#   return json.dumps(output)